---
title: "Fitting procedure"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{fitting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
is_check <- ("CheckExEnv" %in% search()) || any(c("_R_CHECK_TIMINGS_",
             "_R_CHECK_LICENSE_") %in% names(Sys.getenv()))
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = !is_check,
  purl = !is_check
)
```

```{r setup}
library(ppjsdm)
library(spatstat)

remove(list = ls())

set.seed(1)
```

This vignette explains how to calibrate a model in different situations.

# Fitting a sample without traits or covariates

We use the Geyer model.

```{r}
model <- "square_exponential"
medium_range_model <- "square_exponential"
```

We begin by defining the parameters of the point process.

```{r}
nspecies <- 3

alpha <- matrix(cbind(c(-0.6, 0.2, -0.3), c(0.2, -0.2, -0.4), c(-0.3, -0.4, -0.5)), 
                nspecies, 
                nspecies)
gamma <- matrix(cbind(c(0.6, 0.2, -0.3), c(0.2, 0.1, -0.4), c(-0.3, -0.4, 0.3)), 
                nspecies, 
                nspecies)
short_range <- matrix(0.01, nspecies, nspecies)
medium_range <- matrix(0.02, nspecies, nspecies)
long_range <- matrix(0.03, nspecies, nspecies)
log_lambda <- rep(7, nspecies)

configuration <- ppjsdm::rgibbs(lambda = exp(log_lambda), 
                                alpha = alpha,
                                gamma = gamma,
                                model = model,
                                medium_range_model = medium_range_model,
                                short_range = short_range,
                                medium_range = medium_range,
                                long_range = long_range)
print(configuration)
```

The dataset is plotted below.

```{r}
par(mar = c(5, 4, 4, 13) + 0.1)
plot(configuration)
```

The function `gibbsm` fits a multivariate Gibbs point process to our dataset.

```{r}
fit <- ppjsdm::gibbsm(configuration,
                      model = model,
                      medium_range_model = medium_range_model,
                      short_range = short_range,
                      medium_range = medium_range,
                      long_range = long_range)
```

For reference, the actual values used are given below.

```{r}
print(log_lambda)
print(alpha)
print(gamma)
```

# Fitting a sample driven by covariates

To illustrate how the package works, we define arbitrarily the following covariates.

```{r}
temperature <- function(x, y) 1 - 4 * (x - 0.5)^2
wetness <- function(x, y) 0.5 * (1 + sin(pi * 2 * (y - 1)))
elevation <- function(x, y) x

covariates <- list(temperature = temperature, 
                   wetness = wetness,
                   elevation = elevation)
```

We will be using the Geyer model.

```{r}
short_range <- matrix(0.01, 2, 2)
model <- "Geyer"
```

We generate a multivariate Gibbs point process with intensity driven by those covariates.
We begin by defining the parameters of the point process.

```{r}
nspecies <- 2

beta <- cbind(c(1, -2), c(-1, 0.5), c(2, -0.5))
alpha <- matrix(cbind(c(-0.5, 0.1), c(0.1, -0.3)), nspecies, nspecies)
log_lambda <- rep(8, nspecies)
```

Finally, we need a dataset to work on.

```{r}
configuration <- ppjsdm::rgibbs(lambda = exp(log_lambda), 
                                alpha = alpha, 
                                covariates = covariates, 
                                beta = beta,
                                model = model,
                                short_range = short_range)
```

The dataset is plotted below.

```{r}
par(mar = c(5, 4, 4, 13) + 0.1)
plot(configuration)
```

The function `gibbsm` fits a multivariate Gibbs point process to our dataset.

```{r}
fit <- ppjsdm::gibbsm(configuration, 
                      covariates = covariates,
                      model = model,
                      short_range = short_range)
```

For reference, the actual values used are given below.

```{r}
print(log_lambda)
print(beta)
print(alpha)
```

Diagnostics may be obtained as follows.

```{r}
plot(fit$complete)
plot(fit$cv)
```

# Fitting samples driven by traits

This section assumes you have a series of traits explaining a given dataset. 
To illustrate how the package works, we define arbitrarily the following traits.

```{r}
model <- "square_exponential"

nspecies <- 3
short_range <- matrix(0.1, nspecies, nspecies)
medium_range <- matrix(0, nspecies, nspecies)
long_range <- matrix(0, nspecies, nspecies)

average_height <- c(type1 = 0.5, type2 = 1, type3 = 0.4)
average_seed_size <- c(type1 = 2, type2 = 0.1, type3 = 1)

traits <- list(average_height = average_height, average_seed_size = average_seed_size)
```

We generate a multivariate Gibbs point process with repulsion paramaters driven by those traits.
We begin by defining the parameters of the point process.

```{r}
traits_matrix <- rbind(average_height, average_seed_size)
traits_maximum_difference <- apply(traits_matrix, 1, function(c) max(abs(outer(c, c, '-'))))
print(traits_maximum_difference)
traits_maximum <- apply(traits_matrix, 1, function(c) max(abs(c)))
print(traits_maximum)

gamma <- c(0.4, -0.2)
beta <- c(-0.4, -0.6)
delta <- c(0.5, 0.2)

alpha <- matrix(NA, nspecies, nspecies)
for(i in seq_len(nspecies)) {
  for(j in seq_len(nspecies)) {
    if(i == j) {
      alpha[i, j] <- gamma[1] + beta %*% traits_matrix[, i]
    } else {
      alpha[i, j] <- gamma[2] + delta %*% abs(traits_matrix[, i] - traits_matrix[, j])
    }
  }
}
print(alpha)
```

Finally, we sample the observations.

```{r}
configuration <- ppjsdm::rgibbs(lambda = c(150, 150, 150), 
                                alpha = alpha,
                                model = model, 
                                short_range = short_range,
                                medium_range = medium_range,
                                long_range = long_range)
```

The sample is plotted below.

```{r}
par(mar = c(5, 4, 4, 13) + 0.1)
plot(configuration)
```

The function `gibbsm` then fits a multivariate Gibbs point process to our dataset.

```{r}
fit <- ppjsdm::gibbsm(configuration, 
                      traits = traits, 
                      model = model, 
                      short_range = short_range,
                      medium_range = medium_range,
                      long_range = long_range)
```

The actual values used are

```{r}
c(beta, delta)
```
