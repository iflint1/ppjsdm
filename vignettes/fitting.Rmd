---
title: "Fitting procedure"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{fitting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
is_check <- ("CheckExEnv" %in% search()) || any(c("_R_CHECK_TIMINGS_",
             "_R_CHECK_LICENSE_") %in% names(Sys.getenv()))
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = !is_check,
  purl = !is_check
)
```

```{r setup}
library(ppjsdm)
library(spatstat)

remove(list = ls())

set.seed(1)
```

This vignette explains how to calibrate a model in different situations.

# Fitting a sample without traits or covariates

We use the Geyer model.

```{r}
model <- "Geyer"
```

We begin by defining the parameters of the point process.

```{r}
nspecies <- 3

alpha <- matrix(cbind(c(-0.6, 0.2, -0.3), c(0.2, 0.1, -0.4), c(-0.3, -0.4, -0.1)), 
                nspecies, 
                nspecies)
radii <- matrix(0.01, nspecies, nspecies)
log_lambda <- rep(8, nspecies)

configuration <- ppjsdm::rgibbs(lambda = exp(log_lambda), 
                                alpha = alpha,
                                model = model,
                                radius = radii)
```

The dataset is plotted below.

```{r}
par(mar = c(5, 4, 4, 13) + 0.1)
plot(configuration)
```

The function `gibbsm` fits a multivariate Gibbs point process to our dataset.

```{r}
fit <- ppjsdm::gibbsm(configuration,
                      model = model,
                      radius = radii)
```

For reference, the actual values used are given below.

```{r}
print(log_lambda)
print(alpha)
```

# Fitting a sample driven by covariates

To illustrate how the package works, we define arbitrarily the following covariates.

```{r}
temperature <- function(x, y) 1 - 4 * (x - 0.5)^2
wetness <- function(x, y) 0.5 * (1 + sin(pi * 2 * (y - 1)))
elevation <- function(x, y) x

covariates <- list(temperature = temperature, 
                   wetness = wetness,
                   elevation = elevation)
```

We will be using the Geyer model.

```{r}
radii <- matrix(0.01, 2, 2)
model <- "Geyer"
```

We generate a multivariate Gibbs point process with intensity driven by those covariates.
We begin by defining the parameters of the point process.

```{r}
nspecies <- 2

beta <- cbind(c(1, -2), c(-1, 0.5), c(2, -0.5))
alpha <- matrix(cbind(c(-0.5, 0.1), c(0.1, -0.3)), nspecies, nspecies)
log_lambda <- rep(8, nspecies)
```

Finally, we need a dataset to work on.

```{r}
configuration <- ppjsdm::rgibbs(lambda = exp(log_lambda), 
                                alpha = alpha, 
                                covariates = covariates, 
                                beta = beta,
                                model = model,
                                radius = radii)
```

The dataset is plotted below.

```{r}
par(mar = c(5, 4, 4, 13) + 0.1)
plot(configuration)
```

The function `gibbsm` fits a multivariate Gibbs point process to our dataset.

```{r}
fit <- ppjsdm::gibbsm(configuration, 
                      covariates = covariates,
                      model = model,
                      radius = radii)
```

For reference, the actual values used are given below.

```{r}
print(log_lambda)
print(beta)
print(alpha)
```

Diagnostics may be obtained as follows.

```{r}
plot(fit$complete)
plot(fit$cv)
```

# Fitting samples driven by traits

This section assumes you have a series of traits explaining a given dataset. 
To illustrate how the package works, we define arbitrarily the following traits.

```{r}
radii <- matrix(0.1, 2, 2)

average_height <- c(type1 = 1, type2 = 7, type3 = 10)
average_seed_size <- c(type1 = 3, type2 = 5, type3 = 1)

traits <- list(average_height = average_height, average_seed_size = average_seed_size)
```

We generate a multivariate Gibbs point process with repulsion paramaters driven by those traits.
We begin by defining the parameters of the point process.

```{r}
traits_matrix <- rbind(average_height, average_seed_size)
traits_means <- apply(traits_matrix, 1, mean)
  
gamma <- 0
beta <- c(1, -1)

nspecies <- 3
alpha <- matrix(NA, nspecies, nspecies)
for(i in seq_len(nspecies)) {
  for(j in seq_len(nspecies)) {
    alpha[i, j] <- gamma + beta %*% ((traits_matrix[, i] - traits_means) * (traits_matrix[, j] - traits_means) / (traits_means * traits_means))
  }
}
print(alpha)
```

Finally, we sample the observations.

```{r}
configurations <- append(ppjsdm::rgibbs(lambda = c(50, 50), 
                                             alpha = alpha[c(1, 2), c(1, 2)],
                                             nsim = 100, 
                                             types = c("type1", "type2"), 
                                             model = model, 
                                             radius = radii,
                                             drop = FALSE),
                                      
                                      
                         ppjsdm::rgibbs(lambda = c(50, 50), 
                                             alpha = alpha[c(2, 3), c(2, 3)],
                                             nsim = 100,
                                             types = c("type2", "type3"), 
                                             model = model, 
                                             radius = radii,
                                             drop = FALSE))
```

One of the samples is plotted below.

```{r}
par(mar = c(5, 4, 4, 13) + 0.1)
plot(configurations[[1]])
```

The function `gibbsm` then fits a multivariate Gibbs point process to our dataset.

```{r}
fit <- ppjsdm::gibbsm(configurations, 
                      traits = traits, 
                      model = model, 
                      radius = radii, 
                      print = FALSE)
fit$traits
```

The actual values used are

```{r}
c(gamma, beta)
```
