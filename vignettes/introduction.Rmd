---
title: "Introduction"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
is_check <- ("CheckExEnv" %in% search()) || any(c("_R_CHECK_TIMINGS_",
             "_R_CHECK_LICENSE_") %in% names(Sys.getenv()))
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = !is_check,
  purl = !is_check
)
```

```{r setup}
library(ppjsdm)

remove(list = ls())

set.seed(1)
```

# Using covariates

This section assumes you have a series of covariates explaining a given dataset. 
To illustrate how the package works, we define arbitrarily the following covariates.

```{r}
temperature <- function(x, y) 1 - 4 * (x - 0.5)^2
wetness <- function(x, y) 0.5 * (1 + sin(pi * 2 * (y - 1)))

covariates <- list(temperature = temperature, wetness = wetness)
```

Finally, we need a dataset to work on.

```{r}
configuration <- ppjsdm::rppp(lambda = c(50, 50))
```

The function `gibbsm` fits a multivariate Gibbs point process to our dataset.
For example,

```{r}
fit <- ppjsdm::gibbsm(configuration, covariates = covariates)
```

# Using traits

This section assumes you have a series of traits explaining a given dataset. 
To illustrate how the package works, we define arbitrarily the following trait.

```{r}
average_height <- c(type1 = 1, type2 = 7, type3 = 10)
average_seed_size <- c(type1 = 3, type2 = 5, type3 = 1)

traits <- list(average_height = average_height, average_seed_size = average_seed_size)
```

In order to illustrate usage of our package, we generate a multivariate Gibbs point process with repulsion paramaters driven by those traits.

```{r}
traits_matrix <- rbind(average_height, average_seed_size)
traits_means <- apply(traits_matrix, 1, mean)
  
gamma <- 0
beta <- c(1, -1)

nspecies <- 3
alpha <- matrix(NA, nspecies, nspecies)
for(i in seq_len(nspecies)) {
  for(j in seq_len(nspecies)) {
    alpha[i, j] <- gamma + beta %*% ((traits_matrix[, i] - traits_means) * (traits_matrix[, j] - traits_means) / (traits_means * traits_means))
  }
}
print(alpha)
```

Finally, we sample the biased observations.

```{r}
radii <- matrix(0.1, 2, 2)
configurations <- append(ppjsdm::rmultigibbs(lambda = c(50, 50), 
                                             alpha = alpha[c(1, 2), c(1, 2)],
                                             nsim = 100, 
                                             types = c("type1", "type2"), 
                                             model = "Geyer", 
                                             radius = radii,
                                             drop = FALSE),
                                      
                                      
                         ppjsdm::rmultigibbs(lambda = c(50, 50), 
                                             alpha = alpha[c(2, 3), c(2, 3)],
                                             nsim = 100,
                                             types = c("type2", "type3"), 
                                             model = "Geyer", 
                                             radius = radii,
                                             drop = FALSE))
```

The function `gibbsm` then fits a multivariate Gibbs point process to our dataset.
For example,

```{r}
fit <- ppjsdm::gibbsm(configurations, traits = traits, model = "Geyer", radius = radii, print = FALSE)
fit$traits
```

The actual values used are

```{r}
c(gamma, beta)
```
